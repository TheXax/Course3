try {
    var rows = document.querySelectorAll('tbody tr'); //выбирает все строки таблицы
    rows.forEach(function(row, index) {
    var questionCell = row.cells[0]; //получает ячейку первой строки с вопросом
    questionCell.textContent = (index + 1) + '. ' + questionCell.textContent;});//добавляет номер вопроса
   
    //функция для получения ответа
   function Know() {
    let inputQuestion = document.getElementById("question");
    let answer = document.getElementById("answer");
    const answerText = getAnswer(inputQuestion.value); //вызов функции с текстом вопроса
    answer.innerText = answerText; //выводит ответ в элемент страницы
   }



   let knowledge = 
[
  ["Явление интерференции", "проявляется", "при отражении света от тонких прозрачных пленок."],
  ["Мы", "рассмотрим", "процесс возникновения когерентных световых пучков при отражении плоской монохроматической волны с длиной λ от тонкой пластинки толщиной d в месте падения луча."],
  ["Пучок света", "падает", "на пластинку под углом α."],
  ["Среда с показателем преломления", "находится", "по обе стороны от пластинки."],
  ["Два параллельных пучка света", "отражаются", "от пластинки."],
  ["Первый пучок", "образовывается", "при отражении от верхней поверхности пластинки."],
  ["Второй пучок", "образовывается", "при отражении от нижней поверхности."],
  ["Второй пучок", "претерпевает", "преломление при входе в пластинку и при выходе из нее."],
  ["Пучки", "пойдут", "вверх."],
  ["Пучки", "образуются", "в результате кратного отражения от поверхностей пластинки."],
  ["Интерференционная картина", "образуется", "в результате наложения отраженных световых волн."],
  ["Измерение радиусов колец", "выполняется", "с использованием точной оптической техники."],
  ["Интенсивность света", "меняется", "в зависимости от толщины воздушного зазора."],
  ["Форма интерференционных полос", "зависит", "от угла падения светового луча."],
  ["Луч 1", "отражается", "от оптически более плотной среды."],
  ["Изменение фазы колебаний", "происходит", "на π при отражении."],
  ["Потеря полуволны", "вводится", "для учёта изменения фазы колебаний."],
  ["Определённое выражение", "следует", "из треугольника ANB и ВNС ."],
  ["Другое выражение", "следует", "из закона преломления."],
  ["Мы", "получим", "еще одно выражение с учётом закона преломления."],
  ["Отражённые пучки света", "создают", "условия для интерференции в тонкой плёнке."],
  ["Период интерференционной картины", "рассчитывается", "на основе длины световой волны."],
  ["Интерференционные полосы", "возникают", "в результате наложения отраженных лучей."],
  ["Плёнка", "имеет", "разную толщину."],
  ["Параллельный пучок света", "падает", "на плёнку."],
  ["Положение интерференционных полос", "характеризуется", "определёнными значениями тольщины плёнки"],
  ["Полосы", "называются", "полосами равной толщины,  если пленка имеет разную толщину и на нее падает параллельный пучок света (α = const), то положения интерференционных полос будут характеризоваться определенными значениями толщины пленки d."],
  ["Отражение света", "происходит", "в проходящем свете от оптически менее плотной среды."],
  ["Усиление интенсивности света", "наблюдается", "при толщине плёнки равной определенному значению."],
  ["Примером полос равной толщины", "является", "набор колец Ньютона."],
  ["Мы", "можем наблюдать", "кольца от тонкой клиновидной воздушной прослойки, образованной плоскопараллельной пластинкой и соприкасающейся с ней выпуклой линзой с большим радиусом кривизны поверхности."],
  ["Клиновидная воздушная прослойка", "образовывается", "плоскопараллельной пластинкой"],
  ["Клиновидная воздушная прослойка", "соприкасается", "с выпуклой линзой с большим радиусом кривизны поверхности"],
  ["Полосы равной толщины", "будут", "вида эллипсов, при наклонном падении света."],
  ["Полосы равной толщины", "будут", "вида чередующихся тёмных и светлых колец при нормальном падении света."],
  ["Вид колец", "наблюдается", "в отраженном монохроматическом свете."],
  ["Радиусы колец", "зависят", "от радиуса кривизны линзы и длины световой волны."],
  ["Радиусы тёмных колец", "являются", "интерференционным минимумом"],
  ["Радиусы светлых колец", "являются", "интерференционным максимумом"],
  ["Ширина колец", "убывает", "по мере удаления от центрального тёмного пятна."],
  ["Интенсивность колец", "убывает", "по мере удаления от центрального темного пятна."],
  ["Световые волны", "разделяются", "на два пучка, частично отражаясь от нижней поверхности линзы и частично преломляясь."],
  ["Волны", "интерферируют", "между собой, так как угол воздушного зазора обеспечивает условие когерентности."],
  ["Угол воздушного зазора", "обеспечивает", "условие когерентности."],
  ["Оптическая разность хода интерферирующих лучей", "считается", "равной удвоенной толщине, так как n = 1."],
  ["Различие между радиусами соседних колец", "уменьшается", "если m увеличивается."],
  ["Значению m=0", "соответствует", "точка в месте касания пластинки и линзы."],
  ["Минимум интенсивности", "наблюдается", "в точке касания пластинки и линзы."],
  ["Соприкосновение сферической поверхности линзы и пластинки", "невозможно", "в строго данной точке вследствие упругой деформации стекла."],
  ["Центральное пятно", "имеет", "конечные размеры."],
  ["Оптическая толщина воздушного зазора", "возрастает", "при переходе от k-го кольца к m-му на (т-k)λ/2."],
  ["Кольца Ньютона", "наблюдаются", "в результате интерференции света в тонких пленках."],
  ["Интерференция", "возникает", "из-за разности оптических путей двух световых волн."],
  ["Радиус кривизны", "определяется", "по радиусам интерференционных колец."],
  ["Равномерный свет", "создает", "яркие и темные кольца на поверхности линзы."],
  ["Центральное кольцо", "выступает", "как точка максимальной или минимальной интенсивности."],
  ["Параметры линзы", "влияют", "на размер и форму колец Ньютона."],
  ["Измерения радиусов", "осуществляются", "при помощи микроскопа или другой оптики."],
  ["Кольца Ньютона", "используются", "для точных измерений геометрии линзы."],
  ["Линза", "размещается", "на плоской стеклянной поверхности."],
  ["Освещение", "должно", "быть однородным и монохроматическим."],
  ["Фокусное расстояние линзы", "зависит", "от радиуса кривизны линзы."],
  ["Кольца", "становятся", "более чёткиеч при наличии красного света."],
  ["Зеленый свет", "дает", "лучший контраст для наблюдения интерференции."],
  ["Теория", "объясняет", "появление колец через интерференцию волн."],
  ["Форма линзы", "определяет", "характер распределения колец."],
  ["Давление", "влияет", "на контакт линзы с плоской поверхностью."],
  ["Радиус колец", "увеличивается", "при уменьшении длины волны света."],
  ["Оптические свойства линзы", "зависят", "от материала линзы и стекла."],
  ["Центр кольца", "отражает", "точку соприкосновения линзы и стекла."],
  ["Толщина пленки", "увеличивается", "по мере удаления от центра."],
  ["Положение колец", "зависит", "от длины волны и радиуса кривизны."],
  ["Метод измерения радиусов", "требует", "высокой точности."],
  ["Микроскоп", "измеряет", "радиусы ярких и темных зон."],
  ["Физические законы", "объясняют", "появление колец Ньютона."],
  ["Наблюдения", "проводятся", "в темной комнате с однотонным источником света."],
  ["Фазовый сдвиг", "влияет", "на интенсивность колец."],
  ["Кольца Ньютона", "показывают", "границы зон максимума и минимума."],
  ["Яркость кольца", "уменьшается", "с увеличением радиуса кольца."],
  ["Точность", "зависит", "от калибровки измерительного оборудования."],
  ["Результаты", "сравниваются", "с теоретическими расчетами."],
  ["Оптические эксперименты", "используют", "методику наблюдения колец Ньютона."],
  ["Тонкие плёнки", "создают", "разность фаз при отражении света."],
  ["Наблюдатель", "замечает", "периодическое изменение интенсивности."],
  ["Границы", "отмечаются", "на интерференционной картине."],
  ["Линейка", "измеряет", "диаметры кольцевых зон."],
  ["Расчёты", "основываются", "на геометрии линзы и длине волны."],
  ["Тонкая линза", "показывает", "чёткую интерференционную картину."],
  ["Физический эксперимент", "требует", "учёта всех внешних факторов."],
  ["Радиусы", "вычисляются", "по формулам для интерференции."],
  ["Значение радиуса", "зависит", "от длины волны применяемого света."],
  ["Опыт", "подтверждает", "теоретические выводы о природе интерференции."],
  ["Изменение условий", "меняет", "характеристики колец Ньютона."],
  ["Разные условия", "создаются", " для интерференции света при контакте линзы."],
  ["Таблицы", "содержат", "данные о радиусах и расстояниях между кольцами."],
  ["Рефлексия", "приводит", "к появлению новых зон интерференции."],
  ["Методика наблюдения колец Ньютона", "применяется", "в оптике и точных измерениях."],
  ["Волновая теория света", "объясняет", "природу интерференции в тонких плёнках."],
  ["Опыт с тонкими плёнками", "демонстрирует", "влияние длины волны на форму интерференционных полос"],
  ["Изменение угла падения света", "влияет", "на положение интерференционных полос."],
];

//псевдоокончания
   let endings =
     [
       ["ет", "(ет|ут|ют|ем)"],
       ["ут", "(ет|ут|ют|ем)"],
       ["ют", "(ет|ут|ют|ем)"],		     //1 спряжение

       ["ит", "(ит|ат|ят|им)"],
       ["ат", "(ит|ат|ят|им)"],
       ["им", "(ит|ат|ят|им)"],
       ["ят", "(ит|ат|ят|им)"],		     //2 спряжение

       ["ется", "(ет|ут|ют)ся"],
       ["утся", "(ет|ут|ют|ующие)ся"],
       ["ются", "(ет|ут|ют)ся"], //1 спряжение, возвратные

       ["ится", "(ит|ат|ят)ся"],
       ["атся", "(ит|ат|ят)ся"],
       ["ятся", "(ит|ат|ят)ся"],     //2 спряжение, возвратные

       ["ящие", "ящие"],
       ["ee", "ee"],
       ["ен", "ен"],
       ["ую", "ая"],
       ["му", "ма"],
       ["ена", "ена"],
       ["ено", "ено"],
       ["ены", "ены"],		    //краткие прилагательные

       ["ан", "ан"],
       ["ая", "ую"],
       ["ана", "ана"],
       ["ано", "ано"],
       ["аны", "аны"],		    //краткие прилагательные

       ["но", "но"],
       ["на", "на"],

       ["жен", "жен"],
       ["жна", "жна"],
       ["жно", "жно"],
       ["жны", "жны"],

       ["такое", "- это"],
     ]

   let blacklist = []
//поиск сказуемого в вопросе по окончанию. получение индекса окончания
   function getEndingIndex(word) {
     if (blacklist.indexOf(word) !== -1)
       return -1;

       //проверяет есть ли в массиве окончание представленного слова
     for (var j = 0; j < endings.length; j++) {

       if (word.substring(word.length - endings[j][0].length) == endings[j][0])

         return j;
     }

     return -1;

   }


   //изменение регистра
   function firstSymbolToLowerCase(str) {
     return str.substring(0, 1).toLowerCase() + str.substring(1);
   }

   function firstSymbolToUpperCase(str) {
     return str.substring(0, 1).toUpperCase() + str.substring(1);
   }

   //генератор ответов
   function getAnswer(question) {
     let text = firstSymbolToLowerCase(question);

     let separators = "'\",.!?()[]\\/"; //используются для разделения слов

     for (let i = 0; i < separators.length; i++)
       text = text.replace(separators[i], " " + separators[i]);//заменяет символ на тот же символ, но перед ним добавляется пробел для отделениях их от слов

       //слова в вопросе, разбитые ориентируясь на пробелы
     let words = text.split(' ');
   
     for (let i = 0; i < words.length; i++)
       words[i] = firstSymbolToLowerCase(words[i]);

       //найден ли ответ
     let result = false;
     let answer = "";

     //перебор слов из вопроса
     for (let i = 0; i < words.length; i++) {
       let ending = getEndingIndex(words[i]);

       //замена псевдоокончания на возможные окончания
       if (ending >= 0) {
         words[i] = words[i].substring(0, words[i].length - endings[ending][0].length) + endings[ending][1]

         console.log(words)

         //создание регулярного выраждения для поиска сказуемого из вопроса
         let predicate = new RegExp(".*" + words[i] + ".*");

         //если сказуемое не глагол, то захватываетм стоящее за ним слово
         if (endings[ending][0] == endings[ending][1]) {
           predicate = new RegExp(".*" + words[i] + " " + words[i + 1] + ".*");
           i++;  
         }
         console.log(predicate)

         //регулярное выражение для подлежащего из вопроса
         let subjectReg = words.slice(i + 1).join(".*");
         console.log(subjectReg)

         //если в подлежащем больше 3 символов
         if (subjectReg.length > 3) {
           let subject = new RegExp(".*" + subjectReg + ".*");
           console.log(subject)

           //поиск совпадений с шаблонами среди связей семантической сети
           for (let j = 0; j < knowledge.length; j++) {
             if (predicate.test(knowledge[j]?.[1]?.toLowerCase()) && (subject.test(knowledge[j]?.[0]?.toLowerCase()) || subject.test(knowledge[j]?.[2]?.toLowerCase()))) {

              //создание простого предложения из семантической связи
               answer += firstSymbolToUpperCase(knowledge[j][0] + " " + knowledge[j][1] + " " + knowledge[j][2] + "");
               result = true;
             }
           }
           //совпадений по двум шаблонам нет
           if (!result) {
           //поиск по шаблону подлежащего
             for (let j = 0; j < knowledge.length; j++) {
               if (subject.test(knowledge[j]?.[0]?.toLowerCase() || subject.test(knowledge[j]?.[2]?.toLowerCase()))) {
                //создание простого предложения из семантической связи
                 answer += firstSymbolToUpperCase(knowledge[j][0] + " " + knowledge[j][1] + " " + knowledge[j][2] + "");
                 result = true;
                 break;
               }
             }
           }
         }
       }
     }
     //если ответ не найден
     if (!result)
       answer = "Ответ не найден.";
     return answer;
   }
   let res = getAnswer(question);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
   console.log(res + " thos")
 }



 catch (e) {
   console.error(e)
 }

const trs = [...document.querySelectorAll("tbody > tr")];
let question;
let answer;

for (const tr of trs) {
question = tr.querySelector("td").innerText;
answer = getAnswer(question);
tr.innerHTML += `<td ${
 answer === "Ответ не найден." && 'style="background: #ff000056"'
}>${answer}</td>`;
}

